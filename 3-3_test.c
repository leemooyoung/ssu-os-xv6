#include "types.h"
#include "stat.h"
#include "user.h"
#include "fcntl.h"

#define BSIZE 512
#define MODE_DEFALUT 0
#define MODE_PRINT (1<<0)
#define MODE_COUNT (1<<1)
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

char buf[BSIZE];
int rand3[] = {367, 36, 141, 465, 78, 30, 306, 237, 325, 187, \
108, 433, 294, 278, 437, 185, 49, 392, 253, 241, 497, 296, 165, \
478, 0, 464, 74, 420, 277, 124, 448, 230, 440, 129, 112, 144, 308, \
446, 362, 311, 206, 378, 340, 122, 59, 133, 299, 116, 143, 441};

int rand4[] = {276, 98, 299, 439, 190, 424, 84, 335, 228, 403, \
239, 33, 235, 364, 398, 146, 446, 91, 182, 372, 420, 340, 95, 64, \
395, 463, 462, 16, 125, 451, 400, 187, 496, 462, 117, 498, 119, 222, \
499, 312, 326, 312, 302, 421, 413, 135, 74, 357, 158, 29, 99, \
481, 246, 172, 387, 488, 198, 408, 83, 188, 113, 445, 170, 110, 353, \
420, 304, 342, 482, 116, 326, 32, 312, 366, 287, 2, 216, 449, 137, 9, \
173, 206, 350, 181, 241, 247, 447, 233, 426, 12, 420, 298, 182, 358, 154, \
210, 426, 178, 171, 440};

int rand8[] = {
  3076, 4657, 1761, 2393, 3451, 911, 2209, 2112, 2217, 1482,
  1508, 3811, 2429, 125, 2863, 2783, 4115, 4413, 4076, 815,
  271, 196, 637, 3622, 3431, 3974, 3634, 861, 1858, 2301,
  2801, 1962, 587, 1902, 2570, 623, 1535, 2523, 3110, 1496,
  3457, 3075, 4415, 4801, 2534, 3368, 4338, 3161, 1480, 34,
  3691, 1018, 1207, 204, 4426, 3720, 1952, 1597, 1156, 4219,
  4218, 3623, 2181, 2282, 19, 974, 3550, 1604, 4761, 1185,
  637, 187, 4767, 2943, 618, 3329, 1655, 1833, 716, 872,
  3793, 2967, 3330, 4921, 2483, 1036, 4649, 3237, 4449, 848,
  2626, 3033, 1538, 4363, 551, 4069, 4037, 361, 4390, 2280,
  4345, 592, 3040, 4716, 4131, 2009, 615, 4012, 142, 4746,
  1846, 3869, 4644, 1019, 502, 1012, 2475, 3921, 3694, 807,
  4669, 94, 2968, 3822, 829, 1950, 737, 2425, 1563, 1107,
  220, 980, 4360, 3860, 3965, 2056, 2632, 3760, 2507, 1898,
  4175, 383, 1674, 3446, 4815, 718, 3241, 253, 3134, 3318,
  2242, 75, 3053, 2434, 1010, 4708, 3056, 4638, 4459, 2693,
  60, 1481, 1228, 1580, 4497, 2646, 2681, 1726, 2121, 2193,
  565, 496, 4714, 2784, 3088, 1, 362, 969, 3184, 2152,
  1252, 1902, 1627, 1612, 4520, 1923, 1912, 2999, 2032, 3769,
  2558, 1121, 2804, 1706, 2381, 2642, 2656, 2177, 4002, 807,
  1866, 4985, 203, 578, 1550, 3173, 1823, 1922, 4095, 4723,
  4741, 1751, 295, 3230, 2085, 1360, 2133, 4210, 938, 4658,
  2127, 3907, 3689, 2282, 2549, 4066, 1563, 4869, 2382, 2657,
  2533, 110, 3820, 284, 4127, 1451, 2989, 546, 1327, 3789,
  1226, 4584, 4311, 1528, 2293, 421, 1745, 456, 4490, 2260,
  3852, 4427, 1173, 3248, 4453, 3211, 1756, 1499, 4937, 1200,
  1840, 675, 2592, 1423, 3265, 3290, 4110, 1936, 3034, 4288,
  4010, 1437, 1614, 3280, 214, 862, 2889, 4382, 295, 1370,
  2947, 940, 1546, 4242, 871, 3528, 2754, 1269, 951, 2325,
  4322, 1549, 1333, 2356, 3501, 4887, 3817, 4143, 3816, 4543,
  902, 1108, 1091, 1417, 4977, 2932, 4450, 18, 3200, 855,
  4298, 2376, 1331, 4545, 1958, 3957, 2653, 2386, 4466, 1079,
  2805, 1671, 3489, 288, 1550, 488, 243, 4301, 869, 4658,
  562, 373, 495, 3886, 4427, 959, 3048, 2619, 1111, 1141,
  1458, 3558, 2292, 2570, 356, 980, 2727, 4695, 1893, 354,
  2481, 3407, 4755, 648, 2180, 271, 1702, 4706, 2473, 1826,
  1777, 4210, 3386, 263, 1573, 3481, 3496, 4848, 4013, 4409,
  1718, 3795, 3868, 2390, 2445, 3982, 1549, 2204, 4242, 2890,
  4939, 2667, 2705, 3899, 3361, 1472, 4599, 2353, 4482, 3785,
  3784, 3204, 2777, 2478, 2217, 964, 1098, 3132, 2801, 2308,
  8, 331, 260, 186, 3351, 3391, 964, 4422, 4339, 1703,
  3921, 2358, 1118, 4134, 4428, 4058, 2934, 3098, 4061, 2429,
  655, 673, 1084, 2916, 4127, 1420, 4496, 4673, 2583, 3019,
  194, 3779, 2060, 4854, 3394, 67, 1406, 3109, 704, 4688,
  201, 2951, 3079, 3, 837, 4342, 21, 1744, 1144, 3630,
  306, 4273, 2757, 1232, 2022, 1637, 1353, 2561, 955, 524,
  2999, 4017, 2721, 1255, 2627, 1548, 3401, 4271, 75, 888,
  4995, 3549, 2633, 2315, 879, 10, 1691, 1817, 2023, 483,
  4029, 3826, 2635, 489, 2415, 804, 1354, 948, 3710, 3230,
  950, 719, 3503, 3978, 1497, 4668, 2634, 1450, 3409, 1136,
  5, 3674, 2721, 4725, 3482, 1839, 4594, 1153, 193, 2956,
  4483, 4757, 2114, 1053, 2929, 4773, 2814, 1955, 461, 4142,
  4390, 4203, 4986, 4101, 2100, 4567, 4249, 2554, 427, 4334,
  882, 2793, 1421, 1096, 1845, 1831, 4251, 111, 4808, 2555,
  3031, 4797, 1536, 1340, 4734, 2760, 1309, 4297, 2798, 1126,
  3508, 3609, 158, 249, 4186, 3854, 3511, 3569, 4886, 3360,
  1919, 4712, 3080, 434, 3957, 4036, 516, 1002, 1070, 4571,
  1416, 389, 4024, 1338, 1783, 3416, 1854, 4000, 4489, 1185,
  1148, 1576, 4293, 194, 4693, 1178, 3936, 4281, 3763, 85,
  563, 2399, 3028, 4809, 2691, 3141, 3844, 496, 3695, 3081,
  3869, 1222, 2806, 3828, 2709, 887, 4288, 4007, 3553, 542,
  2286, 2754, 3427, 4841, 869, 3777, 754, 898, 1503, 968,
  1565, 2919, 4699, 2393, 835, 4126, 2731, 3226, 1408, 4311,
  4564, 3731, 4775, 2312, 1566, 4461, 4575, 2656, 1979, 2768,
  2219, 3873, 2713, 1774, 2173, 431, 3339, 647, 456, 3101,
  2768, 2193, 1824, 2926, 1689, 804, 2014, 1350, 4804, 1266,
  3650, 693, 1231, 2494, 1547, 3479, 1533, 216, 2949, 1632,
  961, 2800, 3440, 2207, 374, 4915, 244, 1419, 178, 3033,
  4935, 552, 923, 1077, 2606, 1295, 2824, 2620, 639, 4624,
  3979, 2609, 2325, 2805, 3042, 2552, 702, 3264, 2291, 743,
  261, 1897, 4113, 3965, 3305, 1402, 4383, 1447, 1148, 3946,
  4113, 3022, 583, 2778, 4610, 1607, 615, 8, 1356, 3808,
  2577, 3678, 1516, 4775, 2034, 694, 3631, 3332, 2033, 1998,
  894, 4050, 3769, 4882, 3618, 14, 4281, 4458, 2925, 3497,
  2539, 616, 3973, 1132, 39, 4416, 4880, 3881, 701, 770,
  168, 2604, 2924, 2608, 4233, 1529, 1622, 2497, 3923, 4334,
  2929, 526, 4410, 3873, 1737, 3620, 544, 3876, 3372, 829,
  3021, 4, 1346, 2750, 2289, 3864, 4314, 3881, 2384, 317,
  1294, 2537, 1160, 4839, 4076, 1981, 2308, 2788, 1205, 2755,
  2327, 1348, 4659, 3925, 4105, 1204, 939, 2048, 1264, 3079,
  710, 4005, 3370, 3540, 3502, 355, 2575, 4443, 3995, 1177,
  4741, 1465, 2430, 3708, 3315, 2784, 375, 1888, 3528, 539,
  2500, 4182, 3782, 3800, 3282, 2987, 4033, 2759, 2629, 1698,
  2037, 3405, 4376, 4360, 753, 1302, 4675, 4319, 4285, 1966,
  1978, 4293, 2586, 4718, 762, 3497, 838, 3856, 4143, 1367,
  4593, 2946, 3889, 4037, 4902, 3048, 424, 3104, 2417, 823,
  3887, 3970, 4710, 1936, 83, 1526, 2742, 1493, 1421, 2321,
  1412, 1478, 4462, 1103, 3306, 2338, 3579, 591, 3358, 4525,
  535, 1286, 791, 2186, 1344, 2052, 3495, 2293, 3747, 1100,
  3507, 1237, 834, 4659, 2637, 772, 2467, 3842, 2682, 2768,
  4406, 2465, 4111, 1903, 2740, 4309, 4215, 2824, 2799, 3133,
  1391, 39, 861, 1034, 1963, 660, 3124, 4779, 3380, 4240,
  565, 478, 1670, 4156, 4245, 1713, 862, 2994, 1786, 2842,
  2163, 3668, 3391, 4697, 3665, 4415, 4855, 1062, 3005, 643,
  1876, 4804, 2711, 4892, 3068, 2579, 2508, 4530, 4669, 3803,
  2024, 3117, 3788, 92, 2304, 1089, 2458, 4800, 1561, 923,
  3762, 2075, 4771, 1178, 2998, 2762, 980, 180, 1620, 2456,
  4780, 473, 4834, 3981, 485, 1428, 612, 1552, 2856, 2461,
  62, 2663, 3436, 532, 737, 3049, 4378, 3340, 3638, 1366,
  3651, 2752, 2562, 1914, 4954, 4720, 3938, 3283, 4233, 2799
};

void _error(const char *msg) {
	printf(1, msg);
	printf(1, "ssufs_test failed...\n");
	exit();
}

void _success() {
	printf(1, "ok\n");
}

void open_write(char *filename, int blocks){
	int fd, i, ret=0;
	printf(1, "create and write %d blocks...\n", blocks);
	fd = open(filename, O_CREATE | O_WRONLY);

	if (fd < 0)
		_error("File open error\n");

	for (i = 0; i < blocks; i++) {
		ret = write(fd, buf, BSIZE);
		if (ret < 0) break;
	}
	if (ret < 0)
		_error("File write error\n");
	else
		_success();

	printf(1, "close file descriptor...\n");
	
	if (close(fd) < 0)
		_error("File close error\n");
	else
		_success();
}

void rb_test(char *filename, int ntest){
	int fd, i, ret = 0;

	printf(1, "### rb test%d start\n", ntest);
	fd = open(filename, O_RDONLY);
	if (fd < 0)
		_error("File open error\n");

	switch (ntest)
	{
	case 1:
		printf(1, "Basic test\n");

		for(i = 0; i < 5; i++){
			ret = read(fd, buf, BSIZE);
			if (ret < 0) break;

			ret = rb_count(fd);
			if (ret < 0) break;
			ret = rb_print(fd);
			if (ret < 0) break;
		}
		if (ret < 0)
			_error("File read error\n");

		break;

	case 2:
		printf(1, "Large offset test\n");

		ret = lseek(fd, 34000 * BSIZE, SEEK_SET);
		if (ret < 0)
			_error("File read error\n");
	
		for(i = 0; i < 5; i++){
			ret = read(fd, buf, BSIZE);
			if (ret < 0) break;
			ret = rb_count(fd);
			if (ret < 0) break;
			ret = rb_print(fd);
			if (ret < 0) break;
		}
		if (ret < 0)
			_error("File read error\n");

		break;

	case 3:
		printf(1, "no dup random 50 test\n");
		
		for(i = 0; i < 50; i++){
			ret = lseek(fd, rand3[i] * BSIZE, SEEK_SET);
			if (ret < 0) break;
			ret = read(fd, buf, BSIZE);
			if (ret < 0) break;
			ret = rb_count(fd);
			if (ret < 0) break;
			ret = rb_print(fd);
			if (ret < 0) break;
		}
		if (ret < 0)
			_error("File read error\n");

		break;

	case 4:
		printf(1, "dup random 100 test\n");
		
		for(i = 0; i < 100; i++){
			ret = lseek(fd, rand4[i] * BSIZE, SEEK_SET);
			if (ret < 0) break;

			ret = read(fd, buf, BSIZE);
			if (ret < 0) break;

			if(i%10 != 9)
				continue;

			ret = rb_count(fd);
			if (ret < 0) break;
			ret = rb_print(fd);
			if (ret < 0) break;
		}
		if (ret < 0)
			_error("File read error\n");

		break;

	case 5:
		printf(1, "basic old node delete test\n");

		//fill all rb-tree 100 node
		for(i = 0; i < 100; i++){
			ret = read(fd, buf, BSIZE);
			if (ret < 0) break;
		}
		if (ret < 0) 
			_error("File read error\n");

		ret = rb_count(fd);
		if (ret < 0) 
			_error("File read error\n");
		ret = rb_print(fd);
		if (ret < 0) 
			_error("File read error\n");

		//touch node whose key is 1
		ret = lseek(fd, 1 * BSIZE, SEEK_SET);
		if (ret < 0) 
			_error("File read error\n");
		
		ret = read(fd, buf, BSIZE);
		if (ret < 0) 
			_error("File read error\n");

		//go end and read twice
		ret = lseek(fd, 100 * BSIZE, SEEK_SET);
		if (ret < 0) 
			_error("File read error\n");

		ret = read(fd, buf, BSIZE);
		if (ret < 0) 
			_error("File read error\n");

		ret = read(fd, buf, BSIZE);
		if (ret < 0) 
			_error("File read error\n");

		ret = rb_count(fd);
		if (ret < 0) 
			_error("File read error\n");
		ret = rb_print(fd);
		if (ret < 0) 
			_error("File read error\n");

		break;
	
	case 6:
		printf(1, "old node delted with large data\n");
		for(i = 0; i < 500; i++){
			ret = read(fd, buf, BSIZE);
			if (ret < 0) break;
		}
		ret = rb_count(fd);
		if (ret < 0)
			_error("File read error\n");
		ret = rb_print(fd);
		if (ret < 0)
			_error("File read error\n");

		break;

	case 7:
		printf(1, "old node delted with complex data\n");
		for(int j = 1; j <= 10; j++){
			for(i = 0; i < 100; i++){
				ret = lseek(fd, j * i * BSIZE, SEEK_SET);
				if (ret < 0) break;

				ret = read(fd, buf, BSIZE);
				if (ret < 0) break;
			}

			ret = rb_count(fd);
			if (ret < 0)
				_error("File read error\n");
			ret = rb_print(fd);
			if (ret < 0)
				_error("File read error\n");
		}

		break;

	case 8:
		printf(1, "last complex random test\n");
		for(i = 0; i < 1000; i++){
			ret = lseek(fd, rand8[i] * BSIZE, SEEK_SET);
			// if (i == 99) rb_print(fd);
			if (ret < 0) break;
			ret = read(fd, buf, BSIZE);
			if (ret < 0) break;
		}

		ret = rb_count(fd);
		if (ret < 0)
			_error("File read error\n");
		ret = rb_print(fd);
		if (ret < 0)
			_error("File read error\n");

		break;

	default:
		break;
	}
	
	if (close(fd) < 0)
		_error("File close error\n");
	else
		_success();	

		
	printf(1, "### rb test%d end\n", ntest);
}

void test() {
	char filename[16] = "file";
	int fd = 0;
	int i;
	printf(1, "### test start...\n\n");

	open_write(filename, 35000);
	for(i = 1; i <= 8; i++){
		rb_test(filename, i);
		sleep(200);
	}

	printf(1, "unlink %s...\n", filename);

	if (unlink(filename) < 0)
		_error("File unlink error\n");
	else
		_success();

	printf(1, "open %s again...\n", filename);
	fd = open(filename, O_RDONLY);
	
	if (fd < 0) 
		printf(1, "failed\n");
	else
		printf(1, "this statement cannot be runned\n");

	printf(1, "### test passed...\n\n");
}

int main(int argc, char **argv)
{
	for (int i = 0 ; i < BSIZE; i++) {
		buf[i] = BSIZE % 10;
	}

	test();
	exit();
}